#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
   
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <file>\n", argv[0]);
        return EXIT_FAILURE;
    }

    const char *filepath = argv[1];
    int fd = open(filepath, O_RDONLY);
    if (fd == -1) {
        perror("Error ouverture fichier lecture seul");
        return EXIT_FAILURE;
    }

    off_t file_size = lseek(fd, 0, SEEK_END);
    if (file_size == -1) {
        perror("Error getting file size");
        close(fd);
        return EXIT_FAILURE;
    }

    if (file_size == 0) {
        fprintf(stderr, "File is empty\n");
        close(fd);
        return EXIT_FAILURE;
    }

    char *buffer = malloc((file_size - 1)*sizeof(char));
    if (buffer == NULL) {
        perror("Error allocation m√©moire");
        close(fd);
        return EXIT_FAILURE;
    }

    if (lseek(fd, 0, SEEK_SET) == -1) {
        perror("Error seeking to start of file");
        free(buffer);
        close(fd);
        return EXIT_FAILURE;
    }

    ssize_t bytes_read = read(fd, buffer, file_size - 1);
    if (bytes_read == -1) {
        perror("Error lecture du fichier");
        free(buffer);
        close(fd);
        return EXIT_FAILURE;
    }

    close(fd);

    fd = open(filepath, O_WRONLY | O_TRUNC);
    if (fd == -1) {
        perror("Error opening file for writing");
        free(buffer);
        return EXIT_FAILURE;
    }

    ssize_t bytes_written = write(fd, buffer, file_size - 1);
    if (bytes_written == -1) {
        perror("Error writing to file");
        free(buffer);
        close(fd);
        return EXIT_FAILURE;
    }

    free(buffer);
    close(fd);

    return EXIT_SUCCESS;
}