Voici les réponses pour chaque exercice du TP :

---

### Exercice 1 - Premiers scripts

1. **Créer le répertoire `bin` dans votre HOME et copier `punition1.sh`** :
   ```bash
   mkdir -pv ~/bin
   cp /pub/FISE_OSSE11/shell/punition1.sh ~/bin
   ```

2. **Configurer le PATH pour exécuter `punition1.sh` n'importe où** :
   ```bash
   PATH="$PATH:$HOME/bin"
   chmod u+x ~/bin/punition1.sh
   ```
   **Note** : Cette commande devra être relancée dans chaque terminal.

3. **Écrire `punition2.sh`** :
   ```bash
   #!/bin/bash
   n=$1
   m=$2
   word=$3
   for ((i=0; i<n; i++)); do
       line=""
       for ((j=0; j<m; j++)); do
           line="$line $word"
       done
       echo "$line"
   done
   ```

4. **Écrire `punition3.sh`** :
   ```bash
   #!/bin/bash
   n=$1
   m=$2
   word=$3
   str=""
   i=0
   while [ $i -lt $m ]; do
       str="$str $word"
       i=$((i+1))
   done
   punition1.sh "$n" "$str"
   ```

5. **Écrire `punition.sh`** :
   ```bash
   #!/bin/bash
   if [ $# -eq 0 ]; then
       n=10; m=3; word="Je ne bavarde pas en cours !"
   elif [ $# -eq 1 ]; then
       n=10; m=3; word=$1
   elif [ $# -eq 2 ]; then
       n=10; m=$1; word=$2
   else
       n=$1; m=$2; word=$3
   fi
   punition3.sh "$n" "$m" "$word"
   ```

---

### Exercice 2 - Wrapper pour `iacmp`

1. **Lancer `iacmp` sans modification de l’environnement** :
   ```bash
   LD_LIBRARY_PATH=/pub/FISE_OSSE11/shell/iacmp/lib \
   IacmpDir=/pub/FISE_OSSE11/shell/iacmp \
   /pub/FISE_OSSE11/shell/iacmp/iacmp 'chat roux' 'chat blanc' 'chat noir'
   ```

2. **Configurer l’environnement** :
   ```bash
   export LD_LIBRARY_PATH=/pub/FISE_OSSE11/shell/iacmp/lib
   export IacmpDir=/pub/FISE_OSSE11/shell/iacmp
   /pub/FISE_OSSE11/shell/iacmp/iacmp 'chat roux' 'chat blanc' 'chat noir'
   ```

3. **Écrire le script `iacmp`** :
   ```bash
   #!/bin/bash
   export LD_LIBRARY_PATH=/pub/FISE_OSSE11/shell/iacmp/lib
   export IacmpDir=/pub/FISE_OSSE11/shell/iacmp
   exec /pub/FISE_OSSE11/shell/iacmp/iacmp "$@"
   ```

---

### Exercice 3 - Boucles, shift, set

1. **Script `sortarg1`** :
   ```bash
   #!/bin/bash
   for arg in "$@"; do
       echo "$arg"
   done > /tmp/1
   sort /tmp/1 > /tmp/2
   while read -r line; do
       echo -n "$line "
   done < /tmp/2
   echo
   ```

2. **Script `sortarg2` sans fichiers temporaires** :
   ```bash
   #!/bin/bash
   echo "$@" | tr ' ' '\n' | sort | tr '\n' ' '
   echo
   ```

3. **Script `sortarg3`** :
   ```bash
   #!/bin/bash
   while [ "$#" -gt 0 ]; do
       min="$1"
       for arg in "$@"; do
           if [[ "$arg" < "$min" ]]; then
               min="$arg"
           fi
       done
       echo -n "$min "
       set -- "${@/"$min"}"
   done
   echo
   ```

---

### Exercice 4 - Fonctions, if, source

1. **Copier la fonction `s36str` dans `s3tool.sh`**.
   
2. **Ajouter `s36int` pour comparer des entiers** :
   ```bash
   s36int() {
       if [ "$1" -lt "$3" ] && [ "$3" -lt "$5" ]; then
           echo "$2 $4 $6"
       elif [ "$1" -lt "$5" ] && [ "$5" -lt "$3" ]; then
           echo "$2 $6 $4"
       else
           echo "$4 $2 $6"
       fi
   }
   ```

3. **Fonction `isInt`** :
   ```bash
   isInt() {
       local n="$1"
       local m=$(echo "$n" | sed -r -e '1s/[+-]?[0-9]+//')
       test -z "$m"
   }
   ```

---

### Exercice 5 - Utilisation de `s3tool.sh`

1. **Script `s3s` pour trier trois chaînes** :
   ```bash
   #!/bin/bash
   . ~/bin/s3tool.sh
   if [ "$#" -ne 3 ]; then
       echo "error: usage: s3s str1 str2 str3" >&2
       exit 1
   fi
   s36str "$@"
   ```

2. **Script `s3e` pour trier trois entiers** :
   ```bash
   #!/bin/bash
   . ~/bin/s3tool.sh
   if [ "$#" -ne 3 ]; then
       echo "error: usage: s3e int1 int2 int3" >&2
       exit 1
   fi
   s36int "$@"
   ```

3. **Script `s3f` pour trier par taille de fichier** :
   ```bash
   #!/bin/bash
   for file in "$@"; do
       if [ ! -f "$file" ]; then
           echo "error: '$file' is not a regular file" >&2
           exit 3
       fi
   done
   ls -S "$@"
   ```

---

### Exercice 6 - `sleepsort`

1. **Écrire le script `sleepsort`** :
   ```bash
   #!/bin/bash
   for num in "$@"; do
       { sleep "$num"; echo "$num"; } &
   done
   wait
   ```

2. **Questions de l'exercice** :
   - Si on oublie `{ }`, chaque commande `sleep` et `echo` s'exécute dans son propre processus, causant un décalage d’affichage.
   - Le temps d'exécution correspond au plus grand des nombres fournis en argument.
   - Les appels à `wait` permettent d’attendre la fin de chaque tâche en arrière-plan pour s'assurer que tous les nombres sont affichés avant de finir le script.

---

### Exercice 7 - `pidfiles`

1. **Script `pidfiles`** :
   ```bash
   #!/bin/bash
   dir=$1
   if [ ! -d "$dir" ]; then
       echo "Error: Directory not found" >&2
       exit 1
   fi
   find "$dir" -type f -printf "%u\n" | sort | uniq -c
   ```

2. **Option `-s` pour afficher la taille totale** :
   ```bash
   #!/bin/bash
   dir=$1
   if [ "$2" == "-s" ]; then
       find "$dir" -type f -exec du -b {} + | awk '{sum[$2]+=$1} END{for (user in sum) print user, sum[user]}'
   else
       find "$dir" -type f -printf "%u\n" | sort | uniq -c
   fi
   ```

---

### Exercice 8 - Script pour vérifier l'existence de fichiers (examen 2022-2023)

1. **Script `check_files.sh`** :
   ```bash
   #!/bin/bash
   if [ "$#" -eq 0 ]; then
       echo "Error: No arguments provided." >&2
       exit 1
   fi
   for arg in "$@"; do
       if [ -e "$arg" ]; then
           echo "$arg exists"
       else
           echo "$arg does not exist"
       fi
   done
   ```

---

### Exercice 9 - Analyse du script `util.sh` (examen 2017)

1. **Fonction `t`** : vérifie si l’argument est un entier.
2. **Fonction `f`** : calcule la factorielle de l'argument.
3. **Script pour `n!/m!`** :
   ```bash
   #!/bin/bash
   . /chemin/vers/util.sh
   n_fact=$(f "$1")
   m_fact=$(f "$2")
   echo $((n_fact / m_fact))
   ```

---

### Exercice 10 - Script `count.sh` pour compter les occurrences de motifs dans des fichiers

1. **Script `count.sh`** :
   ```bash
   #!/bin/bash
   if [ "$#" -eq 0 ]; then
       echo "Error: No patterns provided." >&2
       exit 1
   fi
   while read -r file; do
       if [ ! -e "$file" ]; then
           echo "$file does not exist"
       elif [ ! -f "$file" ]; then
           echo "$file is not a regular file"
       else
           for pattern in "$@"; do
               count=$(grep -o "$pattern" "$file" | wc -l)
               echo "'$pattern' found $count times in '$file'"
           done
       fi
   done
   ```

---

### Exercice 11 - Code source auto-exécutable (self-executing)

1. **Script `cce`** :
   ```bash
   #!/bin/bash
   code=$(sed -e 1d "$1")
   gcc -x c - <<< "$code" -o /tmp/$$.a.out
   if [ $? -ne 0 ]; then
       echo "Compilation failed."
       exit 2
   fi
   /tmp/$$.a.out "${@:2}"
   ```

2. **Options de gestion des messages de compilation et débogage** :
   ```bash
   if [ -n "$SILENCE" ]; then
       gcc -x c - <<< "$code" -o /tmp/$$.a.out &> /dev/null
   fi
   if [ -n "$DEBUG" ]; then
       gdb /tmp/$$.a.out
   fi
   ```

---

### Exercice 12 - Archive auto-décompressable

1. **Script `shzip` pour encoder en `base64`** :
   ```bash
   #!/bin/bash
   encodefile() {
       base64 "$1" > "$1.b64"
   }
   for file in "$@"; do
       encodefile "$file"
   done
   ```

2. **Option `-z` pour compression avec `gzip`** :
   ```bash
   if [ "$1" == "-z" ]; then
       shift
       gzip -c "$1" > "$1.gz"
       encodefile "$1.gz"
   fi
   ```

---

Voici les versions des scripts avec une gestion des erreurs améliorée pour chaque exercice que vous avez demandé.

---

### Exercice 1 - Script `punition2.sh` avec gestion d’erreurs

```bash
#!/bin/sh
# Usage: punition2.sh <n> <m> <word>

# Vérification du nombre d'arguments
if [ "$#" -ne 3 ]; then
    echo "Usage: $0 <n> <m> <word>" >&2
    exit 1
fi

# Vérification si n et m sont des entiers
if ! [ "$1" -eq "$1" ] 2>/dev/null || ! [ "$2" -eq "$2" ] 2>/dev/null; then
    echo "Erreur : les deux premiers arguments doivent être des entiers." >&2
    exit 1
fi

n="$1"
m="$2"
word="$3"

i=0
while [ "$i" -lt "$n" ]; do
    j=0
    while [ "$j" -lt "$m" ]; do
        echo -n "$word "
        j=$((j + 1))
    done
    echo ""
    i=$((i + 1))
done
```

---

### Exercice 2 - Script `iacmp` avec gestion d’erreurs

```bash
#!/bin/bash
# Wrapper pour /pub/FISE_OSSE11/shell/iacmp/iacmp

# Vérifier que les variables d’environnement sont correctement définies
if [ -z "$IacmpDir" ] || [ -z "$LD_LIBRARY_PATH" ]; then
    echo "Erreur : IacmpDir ou LD_LIBRARY_PATH non défini." >&2
    exit 1
fi

export LD_LIBRARY_PATH="/pub/FISE_OSSE11/shell/iacmp/lib"
export IacmpDir="/pub/FISE_OSSE11/shell/iacmp"
exec /pub/FISE_OSSE11/shell/iacmp/iacmp "$@"
```

---

### Exercice 3 - Script `sortarg1` avec gestion d’erreurs

```bash
#!/bin/bash
# Usage: sortarg1 s1 s2 ... sn

# Vérification du nombre d'arguments
if [ "$#" -eq 0 ]; then
    echo "Usage: $0 <str1> <str2> ... <strN>" >&2
    exit 1
fi

# Stocker les arguments dans un fichier temporaire et trier
for arg in "$@"; do
    echo "$arg"
done > /tmp/sort_input
sort /tmp/sort_input > /tmp/sort_output

# Afficher le résultat trié
while read -r line; do
    echo -n "$line "
done < /tmp/sort_output
echo

# Nettoyer les fichiers temporaires
rm -f /tmp/sort_input /tmp/sort_output
```

---

### Exercice 5 - Script `s3s` avec gestion d’erreurs

```bash
#!/bin/bash
# Usage: s3s str1 str2 str3
. ~/bin/s3tool.sh

# Vérification du nombre d'arguments
if [ "$#" -ne 3 ]; then
    echo "Erreur : Usage: s3s str1 str2 str3" >&2
    exit 1
fi

# Appel de la fonction de tri de `s3tool.sh`
s36str "$@"
```

---

### Exercice 6 - Script `sleepsort` avec gestion d’erreurs

```bash
#!/bin/bash
# Usage: sleepsort n1 n2 ... nk

# Vérification des arguments
if [ "$#" -eq 0 ]; then
    echo "Erreur : fournir au moins un entier positif." >&2
    exit 1
fi

for num in "$@"; do
    if ! [[ "$num" =~ ^[0-9]+$ ]]; then
        echo "Erreur : chaque argument doit être un entier positif." >&2
        exit 1
    fi
done

# Lancer le tri
for num in "$@"; do
    { sleep "$num"; echo "$num"; } &
done
wait
```

---

### Exercice 7 - Script `pidfiles` avec gestion d’erreurs

```bash
#!/bin/bash
# Usage: pidfiles <directory>

# Vérifier que le répertoire est fourni et existe
if [ "$#" -ne 1 ]; then
    echo "Usage: $0 <directory>" >&2
    exit 1
elif [ ! -d "$1" ]; then
    echo "Erreur : $1 n'est pas un répertoire valide." >&2
    exit 1
fi

dir="$1"
find "$dir" -type f -printf "%u\n" | sort | uniq -c
```