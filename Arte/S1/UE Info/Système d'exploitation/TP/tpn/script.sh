#!/bin/bash

fonction1() {
    f=$1
    cat $1 | tr -cs '[:alpha:]' '\n' | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
}

fonction2() {
    f=$1
    sed -n '3~5p' $f
}

# Vérification du nombre d'arguments (c)
if [ "$#" -ne 4 ]; then
    echo "Erreur: Le nombre d'arguments doit être de 4" >&2
    exit 1
fi

# Affectation des arguments
file1=$1
file2=$2
output1=$3
output2=$4

# Vérification d'accès en lecture pour file1 et file2 (d)
for file in "$file1" "$file2"; do
    if [ ! -r "$file" ]; then
        echo "Erreur: Le fichier $file n'est pas accessible en lecture" >&2
        exit 1
    fi
done

# Vérification d'accès en écriture pour output1 et output2 (e)
for output in "$output1" "$output2"; do
    if [ ! -w "$output" ]; then
        echo "Erreur: Le fichier $output n'est pas accessible en écriture" >&2
        exit 1
    fi
done

# Création d'un fichier temporaire
temp_file=$(mktemp)

# Combinaison de file1 et file2 dans le fichier temporaire
cat "$file1" "$file2" > "$temp_file"

# Utilisation de fonction1 sur le fichier temporaire
result=$(fonction1 "$temp_file")

# Récupération du mot le plus fréquent et du mot le moins fréquent
frequent_word=$(echo "$result" | head -n 1 | awk '{print $2}')
frequent_count=$(echo "$result" | head -n 1 | awk '{print $1}')
least_frequent_word=$(echo "$result" | tail -n 1 | awk '{print $2}')
least_frequent_count=$(echo "$result" | tail -n 1 | awk '{print $1}')

# Écriture des résultats dans output1
{
    echo "$frequent_word"
    echo "$frequent_count"
    echo "$least_frequent_word"
    echo "$least_frequent_count"
} > "$output1"


# Nettoyage du fichier temporaire
rm "$temp_file"


# Lecture de l'entier N et vérification de sa validité (g)
echo "Entrez un entier N:"
read -r N
distinct_words=$(fonction1 "$file1" | wc -l)
if [ "$N" -le 0 ] || [ "$N" -ge "$distinct_words" ]; then
    echo "Erreur: N doit être entre 0 et le nombre de mots distincts" >&2
    exit 1
fi

# Écriture des N mots les plus fréquents de file1 dans output1 (h)
fonction1 "$file1" | head -n "$N" | awk '{print $2}' | tr '\n' ' ' >> "$output1"
echo >> "$output1"  # nouvelle ligne à la fin

# Lecture des entiers X et Y et vérification (i)
echo "Entrez un entier X :"
read -r X 
echo "Entrez un entier Y :"
read -r Y
if [ "$X" -le 0 ] || [ "$X" -ge "$Y" ]; then
    echo "Erreur: X doit être inférieur à Y" >&2
    exit 1
fi

# Écriture des modifications de file2 dans output2 (j)
{
    # Remplacement des URL et de 'TD' par 'TP'
    sed -e 's|http://www.ecole.fr/|https://www.ensiie.fr/|Ig' \
        -e 's/\bTD\b/TP/Ig' "$file2"

    # Lignes commençant par 'Unix' entre les lignes X et Y
    sed -n "${X},${Y}p" "$file2" | grep -i '^Unix'

    # Lignes non vides, en excluant celles de X à la fin
    sed -n "1,${X}p" "$file2" | grep -v '^$'

    # Chaque 5ème ligne, en remplaçant la première occurrence de 'shell' par 'bash'
    sed -n '3~5p' "$file2" | sed 's/shell/bash/I'
} > "$output2"

# Affichage des contenus de output1 et output2 sur stdout (k)
cat "$output1" "$output2"

# Création d'une archive avec les fichiers output1 et output2 (l)
tar -cf "quentin_assuncao.tar" "$output1" "$output2"

echo "Script terminé. Archive créée : quentin_assuncao.tar"
